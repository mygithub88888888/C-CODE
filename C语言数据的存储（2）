
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include<stdlib.h>
#include<string.h>
#include<windows.h>
#include<math.h>
#include<time.h>
                    //数据的存储（2）
//int check_sys()
//{
//    int a = 1;
//    char*p = (char*)&a;
//    if(*p==1)
//        return 1;
//    else
//        return 0;
//}
//int main()
//{
//    //写代码告诉当前机器的字节序是什么
//    //如果函数返回1-小端
//    //如果函数返回0-大端
//    int ret = check_sys();
//    if(ret==1)
//    {
//        printf("小端存储\n");
//    }
//    else
//    {
//        printf("大端存储\n");
//    }
//    //return *(char*)&a;---简化写法
////指针类型的意义
////1.决定了指针解引用操作符访问几个字节 char*一个字节 int*四个字节
////2.决定了指针+1或-1时，加减的是几个字节，char*p;p+1;跳过一个字节 int*p;p+1;跳过四个字节
//    /*
//    int a = 1;
//    char*p = (char*)&a;
//    if(*p==1)
//    {
//        printf("小端存储\n");
//    }
//    else
//    {
//        printf("大端存储\n");
//    }
//    */
//    return 0;
//}
/*
//练习1
int main()
//1.输出什么
{
    char a = -1;//在内存中以补码形式存储
    //10000000000000000000000000000001---原码
    //11111111111111111111111111111110---反码
    //11111111111111111111111111111111---补码
    //11111111----a
    //11111111111111111111111111111111----a整型提升的结果
    //打印原码 结果为-1
    signed char b = -1;
    //11111111----b
    //11111111111111111111111111111111----b整型提升的结果
    //打印原码 结果为-1
    unsigned char c = -1;
    //11111111----c
    //00000000000000000000000011111111----c整型提升的结果---无符号数提升高位补0
    //00000000000000000000000011111111----反码---高位是0 正数 原反补相同
    //00000000000000000000000011111111----原码---255
    printf("a=%d,b=%d,c=%d",a,b,c);//-1，-1，255
    return 0;
}
*/
/*
//练习2
//输出什么
int main()
{
    char a = -128;
    //10000000000000000000000010000000---原码
    //11111111111111111111111101111111---反码
    //11111111111111111111111110000000---补码---存在内存里面
    //10000000---a
    //a是char类型 所以只能存8个字节
    //对a进行整形提升
    //11111111111111111111111110000000---补码
    //无符号数 原反补相同
    printf("%u\n",a);//4,294,967,168

    //打印原码---11111111111111111111111110000000---4,294,967,168---计算器

    //---%d---打印10进制有符号数
    //---%u---打印10进制无符号数
    return 0;
}
//有符号char的范围是 -128（10000000）~127（10000001）
//无符号char的范围是 0（00000000）~255（11111111）
*/
/*
//练习3
//比较两个输出结果
int main()
{
    char a = -128;
    printf("%u\n",a);//4,294,967,168
    return 0;
}
int main()
{
    char a = 128;  //在内存中127+1=-128
    printf("%u\n",a);//4,294,967,168
    return 0;
}
//结果相同
*/
/*
//练习4
int main()
//输出结果是什么
{
    int i = -20;
    //10000000000000000000000000010100---原码
    //11111111111111111111111111101011---反码
    //11111111111111111111111111101100---补码

    unsigned int j = 10;
    //00000000000000000000000000001010---原反补相同

    printf("%d\n",i+j); //-10
    //00000000 00000000 00000000 00001010--- 10的补码
    //11111111 11111111 11111111 11101100--- -20的补码                             //shift+字母 = 大写锁定
    //11111111 11111111 11111111 11110110---补码相加的结果
    //11111111 11111111 11111111 11110101---结果的反码
    //10000000 00000000 00000000 00001010---结果的原码
    //输出原码—— -10
    //按照补码形式进行运算，最后格式化成为有符号数
    return 0;
}
*/
/*
//练习5
//输出结果是什么
int main()
{
    unsigned int i;
    for(i = 9;i >= 0;i--)
    {
        printf("%u\n",i); //死循环
        Sleep(100);       //需要头文件#include<windows.h>
    }
    return 0;
}
*/
/*
//练习6
//输出结果是什么
int main()
{
    char a[1000];
    int i;
    for(i=0;i<1000;i++)
    {
        a[i] = -1 - i;
    }
    printf("%d",strlen(a));//255 ---   strlen()---计算字符的长度，遇到"\0"停止
    //有符号char的范围是 -128~127
    //a[i]从a[-1]......a[-128],a[127]......a[1],接下来遇到了0,所以"\0"之前有128+127=255个字符
    return 0;
}
*/
/*
//练习7
//输出结果是什么
unsigned char i = 0;
//无符号char的范围是 0~255
int main()
{
    for(i=0;i <= 255; i++)
    {
        //i的条件恒成立，死循环
        printf("hello world\n");//hello world死循环
    }
    return 0;
}
*/





































